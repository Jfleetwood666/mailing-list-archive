<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="shortcut icon" href="/static/img/favicons/favicon.ico" /><link rel="apple-touch-icon" sizes="57x57" href="/static/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/static/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/static/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/static/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/static/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/static/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/static/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/static/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/static/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/static/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/static/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/static/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/static/img/favicons/favicon-16x16.png"><link rel="manifest" href="/manifest.json"><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><title>cryptoanarchy.wiki - Cypherpunks Mailing List Archive</title><meta name="author" content="cryptoanarchy.wiki" /><meta name="description" content="C1ef71a7193e04c1055a263c8625432762b72985a69cf6e3da13ca0ba260a595" /><meta name="keywords" content="C1ef71a7193e04c1055a263c8625432762b72985a69cf6e3da13ca0ba260a595, cryptoanarchy.wiki - Cypherpunks Mailing List Archive, " /><link rel="alternate" type="application/rss+xml" title="RSS" href="/feed.xml"><meta content="" property="fb:app_id"><meta content="cryptoanarchy.wiki - Cypherpunks Mailing List Archive" property="og:site_name"><meta content="C1ef71a7193e04c1055a263c8625432762b72985a69cf6e3da13ca0ba260a595" property="og:title"><meta content="article" property="og:type"><meta content="Arise, you have nothing to lose but your barbed wire fences!" property="og:description"><meta content="http://localhost:4000/archive/1995/08/c1ef71a7193e04c1055a263c8625432762b72985a69cf6e3da13ca0ba260a595/" property="og:url"><meta content="2018-06-23T00:09:03+02:00" property="article:published_time"><meta content="http://localhost:4000/about/" property="article:author"><meta content="http://localhost:4000/static/img/avatar.jpg" property="og:image"><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@_cryptoanarchy"><meta name="twitter:creator" content="@_cryptoanarchy"><meta name="twitter:title" content="C1ef71a7193e04c1055a263c8625432762b72985a69cf6e3da13ca0ba260a595"><meta name="twitter:url" content="http://localhost:4000/archive/1995/08/c1ef71a7193e04c1055a263c8625432762b72985a69cf6e3da13ca0ba260a595/"><meta name="twitter:description" content="Arise, you have nothing to lose but your barbed wire fences!"><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous"><link rel="stylesheet" href="/static/css/syntax.css"><link href="/static/css/bootstrap.min.css" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Roboto+Condensed:400,300italic,300,400italic,700&amp;subset=latin,latin-ext" rel="stylesheet" type="text/css"><link rel="stylesheet" href="/static/css/super-search.css"><link rel="stylesheet" href="/static/css/thickbox.css"><link rel="stylesheet" href="/static/css/projects.css"><link rel="stylesheet" href="/static/css/main.css"><body><div class="container"><div class="col-sm-3"><div class="fixed-condition"> <a href="/"><img class="profile-avatar" src="/static/img/avatar.jpg" height="75px" width="75px" /></a><h1 class="author-name"><a href="/">cryptoanarchy.wiki</a></h1><div class="profile-about"> Arise, you have nothing to lose but your barbed wire fences!</div><div class="social"><ul><li><a href="https://twitter.com/_cryptoanarchy" target="_blank"><i class="fa fa-twitter"></i></a><li><a href="https://www.facebook.com/cryptoanarchy.wiki" target="_blank"><i class="fa fa-facebook"></i></a><li><a href="https://github.com/cryptoanarchywiki" target="_blank"><i class="fa fa-github"></i></a></ul></div><hr /><ul class="sidebar-nav"> <strong>Navigation</strong><li><a href="https://cryptoanarchy.wiki">Return to cryptoanarchy.wiki</a><li><a href="/">Archive Home</a></ul><hr><ul class="sidebar-nav"> <strong>Similar Resources</strong><li><a class="about" href="https://lopp.net/bitcoin.html" target="_blank">Lopp's Bitcoin Resources</a><li><a class="about" href="https://nakamotoinstitute.org/" target="_blank">Satoshi Nakamoto Institute</a><li><a class="about" href="https://www.activism.net/cypherpunk/" target="_blank">Activism.net: Cypherpunks</a></ul></div></div><div class="col-sm-8 col-offset-1 main-layout"><h1 id="1995-08-15---re-object-oriented-crypto-api">1995-08-15 - Re: Object Oriented Crypto API</h1><h2 id="header-data">Header Data</h2><p>From: “Ray Cromwell” &lt;s5cromw@watson.ibm.com&gt;<br /> To: hfinney@shell.portal.com (Hal)<br /> Message Hash: c1ef71a7193e04c1055a263c8625432762b72985a69cf6e3da13ca0ba260a595<br /> Message ID: &lt;9508152050.AA21250@play.watson.ibm.com&gt;<br /> Reply To: &lt;199508031625.JAA11761@jobe.shell.portal.com&gt;<br /> UTC Datetime: 1995-08-15 20:51:27 UTC<br /> Raw Date: Tue, 15 Aug 95 13:51:27 PDT<br /><h2 id="raw-message">Raw message</h2><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>From: "Ray Cromwell" &lt;s5cromw@watson.ibm.com&gt;
Date: Tue, 15 Aug 95 13:51:27 PDT
To: hfinney@shell.portal.com (Hal)
Subject: Re: Object Oriented Crypto API
In-Reply-To: &lt;199508031625.JAA11761@jobe.shell.portal.com&gt;
Message-ID: &lt;9508152050.AA21250@play.watson.ibm.com&gt;
MIME-Version: 1.0
Content-Type: text/plain



Sorry I took so long to respond.

Hal wrote:
&gt; I enjoyed Ray's message about the crypto library interface.  I haven't
&gt; had time to study it closely, but I have a couple of quick comments:
&gt;
&gt; I thought Wei's library looked pretty easy to use already.  Maybe Ray
&gt; could show an example of what would be needed with Wei's library to do
&gt; some "typical" crypto function, say encrypting a message with someone
&gt; else's RSA key.  Then we could compare it with how the same function
&gt; would look with Ray's proposed interface.

  Wei's library is easy to use from a certain standpoint. It depends
on a ASN.1 stream paradigm to stack cryptographic layers. However, I
think it is lacking in certain areas which makes it difficult
to use, and it is completely missing many functions such as
key distribution and management.

To RSA encrypt with Wei's library, you have to open the key file
(or read it into memory somehow), and instantiate a "BufferedTransformation"
which is a sort of internal stream library. Then you construct
a RSAPublicKey object around the BufferedTransformation, then you
generate a random blockcipher key, and tell the RSAPublicKey object
to encrypt it. Next, you encode your plaintext with the block cipher
separately using the blockcipher key. I'm going to ignore the
actual syntax of Wei's library for the moment (because I don't remember
it) and use pseudo code.

key_data_stream = FileSource("publickey.data") /* like ifstream() */
RSAPublicKey rsa_object(key_data_stream);
random_blockcipher_key = /* generate the key somehow, note, key generation
	                    is not standardized across all encryption
                            algorithms, so the application writer
                            must know how to generate the session key
                            manually */
rsa_object.Encrypt(random_blockcipher_key, encryptedkey);
DESEncryption desenc(random_blockcipher_key);
desenc.ProcessBlock(plaintext, ciphertext);
/* write "encryptedkey" and "ciphertext" somewhere */






Under my scheme, it would look something like this

/* we are given PlainText p, a KeyID which is of the format
   KeyID ::= identifier ['::' keyserver]
   identifier ::= RFC822_EMAIL_ADDR | HEX_STRING;
   keyserver ::= FULLY_QUALIFIED_DOMAIN_NAME;

   example: "Ray Cromwell" &lt;rjc@clark.net&gt;::keyserver.com
   we are doing RSA encryption with DES
*/

DESEncryptionAlgorithm des;
RSAEncryptionAlgorithm rsa(des);

Encrypt(rsa, KeyId, p, c);




Here's the explaination of what's going on underneath (refer to
my OO Crypto API article if needed)

DES is a BlockCipherEncryptionAlgorithm (child of EncryptionAlgorithm)
RSA is a PublicKeyEncryptionAlgorithm (also a child of EncryptionAlgorithm)
that expects to be constructed with a BlockCipherEncryptionAlgorithm
because it uses a blockcipher as the underlying encryption technique
and only encrypts the session key. Any old BlockCipherEncryptionAlgorithm
will do, DES, IDEA, etc. RSA doesn't care.

Encrypt() is a global function which takes as its first argument
an EncryptionAlgorithm, second, a KeyID, and third/fourth a plaintext
and ciphertext tokenized stream (to be explained later). Encrypt()
doesn't care what the cryptosystem is, it's a single entry point
for the application developer.

Encrypt's pseudocode looks like this

Encrypt(EncryptionAlgorithm encalg, KeyID kid, Plaintext p, Ciphertext c)
{
    KeyDomain kdom=encalg.GetKeyDomain(kid);
    EncryptionKey ek = GetKey(kdom, kid);
    encalg.encrypt(ek, p, c);
}

Line 1 asks the EncryptionAlgorithm (whatever type it really is), to
return a KeyDomain for that cryptosystem. A KeyDomain is an abstract
universal object for fetching any key type from any place. It could
for instance, be fetching the key from a disk file, from an email
signature, or am internet key server.

Line 2 calls a global key management function GetKey which queries
a KeyDomain with the KeyID to return an EncryptionKey.

Line 3 calls the encrypt function on the EncryptionAlgorithm.

I have toyed with other interfaces. For instance, since we want to
support the definition of new KeyDomain types, we really should allow
an overloaded Encrypt where the EncryptionKey is passed as an argument,
so that the application developer can use third party KeyDomains.

Every EncryptionAlgorithm (hereafter abbreviated EA, where DA is
a DecryptionAlgorithm) knows how to generate a KeyPair which
contains an encryption and decryption key such that
DA(keypair.decryption_key, EA(keypair.encryption_key, plaintext)) == plaintext
Whether the cipher is symmetric or not is irrevelent. The RSAEncryptionAlgorithm
encrypt() function basically calls generate_key() on the block cipher
and uses that as the session key. Application developers are shielded
from the representation of keys and the generation of them.


The real dream is to have a generic crypto library which can encrypt
anything using any algorithm fetching keys from any medium and
reading and writing any valid crypto file format. Application developers
could write code to operate on PGP file formats, RSAREF, PEM, or
anything without having to know anything about those formats at all.
The only thing that is standardized is the KeyID format. Sort of
a Universal Resource Name (URN) for key identification. Perhaps
"key://keyserver.domain/keyid" would be better.


Reading and Writing any file format
-----------------------------------
  How would an application be able to operate on a RIPEM message, and a
PGP file without knowing about the format of either?

  The general scheme is to use a tokenized stream which records
what has been done to the plaintext, and then some stream encoding
objects which "map" the stream to the local format as long as the
stream is consistent with the algorithms the file format supports. Think
of the stream as a string in a regular language (in the sense of automata
theory). The stream "mapper" is a deterministic finite automaton
which processes the "string" (the stream tokens) and determines
1) whether the string is acceptable by the language (file format)
it's mapping to, and 2) generates side effects which write out the
format to a buffer or file.

Consider the following symbol set,
S={ RSA_ENCRYPTION, PUBLICKEY_REF, DES_ENCRYPTION, IDEA_ENCRYPTION }

A tokenized stream might look like

RSA_ENCRYPTION PUBLICKEY_REF [pkey data] [encrypted session key]
DES_ENCRYPTION [ciphertext]

A PGPEncoder would reject this stream because it doesn't use IDEA.


Encoders would have the job of verifying consistency of the
stream with the underlying file format, and also whether or not
the stream was encoded properly in the first place. If the
stream is invalid, exceptions are thrown. If some tokens are
missing (such as a timestamp), the Encoder can supply them.

&gt; The other point is that there needs to be the ability to encrypt only
&gt; a bit of a message at a time.  Particularly with public key the first
&gt; message may be special in that it generates a session key which is used
&gt; for the remainder.  So an interface for piecewise encryption and
&gt; decryption is necessary.

The way to do this is to provide secondary interfaces across all
Algorithms which allow the operations of Init, Update, and Finalize,
much like RSA's MD5 interface operates.

-Ray



From owner-cypherpunks  Tue Aug 15 15:06:28 1995




</code></pre></div></div><h2 id="thread">Thread</h2><ul><li><p>Return to <a href="/archive/1995/08">August 1995</a><li><p>1995-08-03 (Thu, 3 Aug 95 09:26:31 PDT) - <a href="/archive/1995/08/ad29d572df129cca217afe1e50a3636cf0f1f3688a8fa9c32c07f5a5e85cce1d">Re: Object Oriented Crypto API</a> - <em>Hal &lt;hfinney@shell.portal.com&gt;</em><ul><li>1995-08-03 (Thu, 3 Aug 95 11:22:19 PDT) - <a href="/archive/1995/08/ab8a290b9a5530d4b3f62b1e91911a8cc5aa2216fd82a7ad63b343eb25156f8d">Re: Object Oriented Crypto API</a> - <em>Adam Shostack &lt;adam@bwh.harvard.edu&gt;</em><li>1995-08-15 (Tue, 15 Aug 95 13:51:27 PDT) - Re: Object Oriented Crypto API - <em>“Ray Cromwell” &lt;s5cromw@watson.ibm.com&gt;</em></ul></ul><footer> - <a href="https://github.com/cryptoanarchywiki/mailing-list-archive">https://github.com/cryptoanarchywiki/mailing-list-archive</a></footer></div></div><script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script> <script src="//code.jquery.com/jquery-migrate-1.2.1.min.js"></script> <script src="/static/js/bootstrap.min.js"></script> <script src="/static/js/super-search.js"></script> <script src="/static/js/thickbox-compressed.js"></script> <script src="/static/js/projects.js"></script>
