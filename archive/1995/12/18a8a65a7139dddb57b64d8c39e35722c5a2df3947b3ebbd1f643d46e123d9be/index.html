<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="shortcut icon" href="/static/img/favicons/favicon.ico" /><link rel="apple-touch-icon" sizes="57x57" href="/static/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/static/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/static/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/static/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/static/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/static/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/static/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/static/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/static/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/static/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/static/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/static/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/static/img/favicons/favicon-16x16.png"><link rel="manifest" href="/manifest.json"><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><title>cryptoanarchy.wiki - Cypherpunks Mailing List Archive</title><meta name="author" content="cryptoanarchy.wiki" /><meta name="description" content="18a8a65a7139dddb57b64d8c39e35722c5a2df3947b3ebbd1f643d46e123d9be" /><meta name="keywords" content="18a8a65a7139dddb57b64d8c39e35722c5a2df3947b3ebbd1f643d46e123d9be, cryptoanarchy.wiki - Cypherpunks Mailing List Archive, " /><link rel="alternate" type="application/rss+xml" title="RSS" href="/feed.xml"><meta content="" property="fb:app_id"><meta content="cryptoanarchy.wiki - Cypherpunks Mailing List Archive" property="og:site_name"><meta content="18a8a65a7139dddb57b64d8c39e35722c5a2df3947b3ebbd1f643d46e123d9be" property="og:title"><meta content="article" property="og:type"><meta content="Arise, you have nothing to lose but your barbed wire fences!" property="og:description"><meta content="http://localhost:4000/archive/1995/12/18a8a65a7139dddb57b64d8c39e35722c5a2df3947b3ebbd1f643d46e123d9be/" property="og:url"><meta content="2018-06-27T00:58:45+02:00" property="article:published_time"><meta content="http://localhost:4000/about/" property="article:author"><meta content="http://localhost:4000/static/img/avatar.jpg" property="og:image"><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@_cryptoanarchy"><meta name="twitter:creator" content="@_cryptoanarchy"><meta name="twitter:title" content="18a8a65a7139dddb57b64d8c39e35722c5a2df3947b3ebbd1f643d46e123d9be"><meta name="twitter:url" content="http://localhost:4000/archive/1995/12/18a8a65a7139dddb57b64d8c39e35722c5a2df3947b3ebbd1f643d46e123d9be/"><meta name="twitter:description" content="Arise, you have nothing to lose but your barbed wire fences!"><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous"><link rel="stylesheet" href="/static/css/syntax.css"><link href="/static/css/bootstrap.min.css" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Roboto+Condensed:400,300italic,300,400italic,700&amp;subset=latin,latin-ext" rel="stylesheet" type="text/css"><link rel="stylesheet" href="/static/css/super-search.css"><link rel="stylesheet" href="/static/css/thickbox.css"><link rel="stylesheet" href="/static/css/projects.css"><link rel="stylesheet" href="/static/css/main.css"><body><div class="container"><div class="col-sm-3"><div class="fixed-condition"> <a href="/"><img class="profile-avatar" src="/static/img/avatar.jpg" height="75px" width="75px" /></a><h1 class="author-name"><a href="/">cryptoanarchy.wiki</a></h1><div class="profile-about"> Arise, you have nothing to lose but your barbed wire fences!</div><div class="social"><ul><li><a href="https://twitter.com/_cryptoanarchy" target="_blank"><i class="fa fa-twitter"></i></a><li><a href="https://www.facebook.com/cryptoanarchy.wiki" target="_blank"><i class="fa fa-facebook"></i></a><li><a href="https://github.com/cryptoanarchywiki" target="_blank"><i class="fa fa-github"></i></a></ul></div><hr /><ul class="sidebar-nav"> <strong>Navigation</strong><li><a href="https://cryptoanarchy.wiki">Return to cryptoanarchy.wiki</a><li><a href="/">Archive Home</a><li><a href="/archive/">Posts by Year</a><li><a href="/authors/by-posts/">Authors by Post Number</a><li><a href="/authors/notable/">Notable Authors</a></ul><hr><ul class="sidebar-nav"> <strong>Similar Resources</strong><li><a class="about" href="https://lopp.net/bitcoin.html" target="_blank">Lopp's Bitcoin Resources</a><li><a class="about" href="https://nakamotoinstitute.org/" target="_blank">Satoshi Nakamoto Institute</a><li><a class="about" href="https://www.activism.net/cypherpunk/" target="_blank">Activism.net: Cypherpunks</a></ul></div></div><div class="col-sm-8 col-offset-1 main-layout"><h1 id="1995-12-28---cryptolib-11-rsac">1995-12-28 - Cryptolib 1.1 rsa.c</h1><h2 id="header-data">Header Data</h2><p>From: cpunk<span>@</span>remail.ecafe.org (ECafe Anonymous Remailer)<br /> To: cypherpunks@toad.com<br /> Message Hash: 18a8a65a7139dddb57b64d8c39e35722c5a2df3947b3ebbd1f643d46e123d9be<br /> Message ID: &lt;199512281722.RAA18284@pangaea.ang.ecafe.org&gt;<br /> Reply To: <em>N/A</em><br /> UTC Datetime: 1995-12-28 17:21:40 UTC<br /> Raw Date: Thu, 28 Dec 95 09:21:40 PST<br /><h2 id="raw-message">Raw message</h2><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>From: cpunk@remail.ecafe.org (ECafe Anonymous Remailer)
Date: Thu, 28 Dec 95 09:21:40 PST
To: cypherpunks@toad.com
Subject: Cryptolib 1.1 rsa.c
Message-ID: &lt;199512281722.RAA18284@pangaea.ang.ecafe.org&gt;
MIME-Version: 1.0
Content-Type: text/plain


I am informed that there is a serious bug in the version of cryptolib
that gets sent to people who don't have RSA licenses.  The bug
prevents it from doing RSA encrypt, decrypt or signature.  I cannot
imagine how this bug slipped through but it seems only to exist in the
copies of cryptolib that are sent to those without RSA licenses.
Fortunately I have an RSA licesnse and so my new copy (thanks Jack and
Matt!) does not suffer from the bug.

Here is the version of rsa.c that fixes the bug.

/*
 * This is version 1.1 of CryptoLib
 *
 * The authors of this software are Jack Lacy, Don Mitchell and Matt Blaze
 *              Copyright (c) 1991, 1992, 1993, 1994, 1995 by AT&amp;T.
 * Permission to use, copy, and modify this software without fee
 * is hereby granted, provided that this entire notice is included in
 * all copies of any software which is or includes a copy or
 * modification of this software and in all copies of the supporting
 * documentation for such software.
 *
 * NOTE:
 * Some of the algorithms in cryptolib may be covered by patents.
 * It is the responsibility of the user to ensure that any required
 * licenses are obtained.
 *
 *
 * SOME PARTS OF CRYPTOLIB MAY BE RESTRICTED UNDER UNITED STATES EXPORT
 * REGULATIONS.
 *
 *
 * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTY.  IN PARTICULAR, NEITHER THE AUTHORS NOR AT&amp;T MAKE ANY
 * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY
 * OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.
 */

/*
 *        Code for generating and manipulating RSA keys
 *        and doing encryption and decryption using RSA.
 *        AT&amp;T recognizes that RSA is patented
 *        (Rivest et. al. U.S. Patent 4,405,829, issued 9/20/83).
 *	  Use of this code assumes proper licensing.
 *
 *        coded by Jack Lacy, December, 1991
 *
 */
#include "libcrypt.h"

static Key_exps *genKeyExps P((BigInt, BigInt, BigInt, int, BigInt));
static void chineseRemTheorem P((BigInt , RSAPrivateKey *, BigInt));
static void genPrimesFor3 P((int, BigInt, BigInt, BigInt, BigInt));

#ifdef K_AND_R
static Key_exps *
genKeyExps(p, q, e, ebits, randomStart)
  BigInt p, q, e;
  int ebits;
  BigInt randomStart;
#else
  static Key_exps *genKeyExps(BigInt p,
			      BigInt q,
			      BigInt e,
			      int ebits,
			      BigInt randomStart)
#endif
{
	BigInt phi, p1, q1;
	BigInt u1, ngcd, ignore;
	Key_exps *exps;
	int ebytes;
#ifdef DLLEXPORT
	HGLOBAL handle = clib_malloc(sizeof(Key_exps));
	exps = (Key_exps *)GlobalLock(handle);
	exps-&gt;exp_handle = handle;
#else
	exps = (Key_exps *)clib_malloc(sizeof(Key_exps));
#endif
	p1 = bigInit(0);
	q1 = bigInit(0);
	phi = bigInit(0);
	u1  = bigInit(0);
	ngcd = bigInit(0);
	ignore = bigInit(0);
	if (e == NULL)
		e = bigInit(3);
	
	bigSubtract(p, one, p1);
	bigSubtract(q, one, q1);
	bigMultiply(p1, q1, phi);
	freeBignum(p1);
	freeBignum(q1);
	
	/* Get public exponent, relatively prime to modulus. */
	/* A by product of the extendedGcd calculation is the inverse
	   of e mod phi, which is d, the private exponent.
	   If e has been specified, skip this.
	 */
	if (e == NULL) {
		if (ebits &gt; 2) {
			ebytes = (ebits/8) + (ebits%8? 1: 0);
			if (randomStart == NULL) {
				bigRand(ebytes, e, PSEUDO);
			}
			else {
				bigCopy(randomStart, e);
			}
			if (EVEN(e))
				bigAdd(e, one, e);
		}
	}
	extendedGcd(e, phi, u1, ignore, ngcd);
	while (bigCompare(ngcd, one) != 0) {
		bigAdd(e, two, e);
		extendedGcd(e, phi, u1, ignore, ngcd);
	}
	exps-&gt;d = u1;
	exps-&gt;e = e;
	
	freeBignum(phi);
	freeBignum(ngcd);
	freeBignum(ignore);
	
	return exps;
}

#ifdef K_AND_R
_TYPE( RSAPublicKey * )
buildRSAPublicKey(e, n)
  BigInt e, n;
#else
_TYPE( RSAPublicKey * ) buildRSAPublicKey(BigInt e,
					  BigInt n)
#endif
{
	RSAPublicKey *pk;
#ifdef DLLEXPORT
	HGLOBAL handle = clib_malloc(sizeof(RSAPublicKey));
	pk = (RSAPublicKey *)GlobalLock(handle);
	pk-&gt;pubkey_handle = handle;
#else
	pk = (RSAPublicKey *)clib_malloc(sizeof(RSAPublicKey));
#endif
	pk-&gt;publicExponent = e;
	pk-&gt;modulus = n;
	return pk;
}

#ifdef K_AND_R
_TYPE( RSAPrivateKey * )
buildRSAPrivateKey(e, d, p, q, dp, dq, c12)
  BigInt e, d, p, q, dp, dq, c12;
#else
_TYPE( RSAPrivateKey * ) buildRSAPrivateKey(BigInt e,
					    BigInt d,
					    BigInt p,
					    BigInt q,
					    BigInt dp,
					    BigInt dq,
					    BigInt c12)
#endif
{
	RSAPrivateKey *pk;
	ChineseRemStruct *crt;
#ifdef DLLEXPORT
	HGLOBAL crt_handle = clib_malloc(sizeof(ChineseRemStruct));
	HGLOBAL handle = clib_malloc(sizeof(RSAPrivateKey));
	crt = (ChineseRemStruct *)GlobalLock(crt_handle);
	crt-&gt;crt_handle = crt_handle;
	pk = (RSAPrivateKey *)GlobalLock(handle);
	pk-&gt;privkey_handle = handle;
#else
	crt = (ChineseRemStruct *)clib_malloc(sizeof(ChineseRemStruct));
	pk = (RSAPrivateKey *)clib_malloc(sizeof(RSAPrivateKey));
#endif
	
	pk-&gt;publicExponent = e;
	pk-&gt;privateExponent = d;
	pk-&gt;modulus = bigInit(0);
	bigMultiply(p, q, pk-&gt;modulus);
	
	pk-&gt;crt = crt;
	pk-&gt;crt-&gt;p = p;
	pk-&gt;crt-&gt;q = q;
	pk-&gt;crt-&gt;dp = dp;
	pk-&gt;crt-&gt;dq = dq;
	pk-&gt;crt-&gt;c12 = c12;
	
	return pk;
}

#ifdef K_AND_R
_TYPE( RSAKeySet * )
buildRSAKeySet(e, d, p, q)
  BigInt e, d, p, q;
#else
_TYPE( RSAKeySet * ) buildRSAKeySet(BigInt e,
				    BigInt d,
				    BigInt p,
				    BigInt q)
#endif
{
	BigInt pminus1, qminus1, n, dp, dq, c12;
	BigInt ecopy, dcopy;
	RSAKeySet *ks;
#ifdef DLLEXPORT
	HGLOBAL ks_handle = clib_malloc(sizeof(RSAKeySet));
	ks = (RSAKeySet *)GlobalLock(ks_handle);
	ks-&gt;keyset_handle = ks_handle;
#else
	ks = (RSAKeySet *)clib_malloc(sizeof(RSAKeySet));
#endif
	n = bigInit(0);
	bigMultiply(p, q, n);
	
	ecopy = bigInit(0);
	bigCopy(e, ecopy);
	ks-&gt;publicKey = buildRSAPublicKey(ecopy, n);
	
	pminus1 = bigInit(0);
	qminus1 = bigInit(0);
	bigSubtract(p, one, pminus1);
	bigSubtract(q, one, qminus1);
	
	dp = bigInit(0);
	dq = bigInit(0);
	bigMod(d, pminus1, dp);
	bigMod(d, qminus1, dq);
	
	c12 = bigInit(0);
	getInverse(q, p, c12);

	ecopy = bigInit(0);
	bigCopy(e, ecopy);
	dcopy = bigInit(0);
	bigCopy(d, dcopy);
	ks-&gt;privateKey = buildRSAPrivateKey(ecopy, dcopy, p, q,
					    dp, dq, c12);
	
	freeBignum(pminus1);
	freeBignum(qminus1);
	
	return ks;
}


#ifdef K_AND_R
static void
genPrimesFor3(nbits, p, q, r1, r2)
  int nbits;
  BigInt p, q, r1, r2;
#else
  static void genPrimesFor3(int nbits,
			    BigInt p,
			    BigInt q,
			    BigInt r1,
			    BigInt r2)
#endif
{
	BigInt ngcd, ignore, three, pminus1, qminus1;
	
	ignore = bigInit(0);
	three = bigInit(3);
	pminus1 = bigInit(0);
	qminus1 = bigInit(0);

	/* Gordon algorithm doesn't care about the p-1 factor size */
	genStrongPrimeSet(nbits/2, p, (int)NULL, ignore, GORDON, r1);
	bigSubtract(p, one, pminus1);
	ngcd = gcd(three, pminus1);
	while (bigCompare(ngcd, one) != 0) {
		if (r1 != NULL)
			randomize(r1);
		freeBignum(ngcd);
		genStrongPrimeSet(nbits/2, p, (int)NULL, ignore, GORDON, r1);
		bigSubtract(p, one, pminus1);
		ngcd = gcd(three, pminus1);
	}
	freeBignum(ngcd);
	
	genStrongPrimeSet(nbits/2, q, (int)NULL, ignore, GORDON, r2);
	bigSubtract(q, one, qminus1);
	ngcd = gcd(three, qminus1);
	while (bigCompare(ngcd, one) != 0) {
		if (r2 != NULL)
			randomize(r2);
		freeBignum(ngcd);
		genStrongPrimeSet(nbits/2, q, (int)NULL, ignore, GORDON, r2);
		bigSubtract(q, one, qminus1);
		ngcd = gcd(three, qminus1);
	}
	freeBignum(ngcd);
	freeBignum(pminus1);
	freeBignum(qminus1);
	freeBignum(ignore);
	freeBignum(three);
}


#ifdef K_AND_R
_TYPE( int )
randBytesNeededForRSA (modlen, ebits)
  int modlen, ebits;
#else
_TYPE( int ) randBytesNeededForRSA (int modlen, int ebits)
#endif
{
	int bytes;

	bytes = ((modlen + ebits)/8) + ((modlen+ebits)%8? 1: 0);

	return bytes;
}

#ifdef K_AND_R
_TYPE( RSAKeySet * )
genRSAKeySet(nbits, ebits, e, randomStart)
  Ulong nbits, ebits, randomStart;
  BigInt e;
#else
_TYPE( RSAKeySet * ) genRSAKeySet(int nbits,
				  int ebits,
				  BigInt e,
				  BigInt randomStart)
#endif
{
	BigInt p, q, ignore, r1, r2;
	Key_exps *exps;
	RSAKeySet *key_set;
	int oldlen;
	BigInt randStart;
	
	p = bigInit(0);
	q = bigInit(0);
	r1 = NULL;
	r2 = NULL;
	randStart = NULL;
	if (randomStart != NULL) {
		r1 = bigInit(0);
		r2 = bigInit(0);
		randStart = bigInit(0);
		bigCopy(randomStart, randStart);
		oldlen = LENGTH(randStart);
		LENGTH(randStart) = nbits/32/2;
		bigCopy(randStart, r1);
		LENGTH(randStart) = oldlen;
		bigRightShift(randStart, nbits/2, randStart);
		oldlen = LENGTH(randStart);
		LENGTH(randStart) = nbits/32/2;
		bigCopy(randStart, r2);
		LENGTH(randStart) = oldlen;
		bigRightShift(randStart, nbits/2, randStart);
	}
	if (ebits == 2)
		genPrimesFor3(nbits, p, q, r1, r2);
	
	else {
		ignore = bigInit(0);
		genStrongPrimeSet(nbits/2, p, (int)NULL, ignore, GORDON, r1);
		genStrongPrimeSet(nbits/2, q, (int)NULL, ignore, GORDON, r2);
		freeBignum(ignore);
	}
	exps = genKeyExps(p, q, e, ebits, randStart);
	key_set = buildRSAKeySet(exps-&gt;e, exps-&gt;d, p, q);
	freeBignum(exps-&gt;e);
	freeBignum(exps-&gt;d);
	if (r1 != NULL) {
		freeBignum(r1);
		freeBignum(r2);
		freeBignum(randStart);
	}
#ifdef DLLEXPORT
	GlobalUnlock(exps-&gt;exp_handle);
	GlobalFree(exps-&gt;exp_handle);
#else
	free((char *)exps);
#endif
	return key_set;
}


/*
   Chinese Remainder Theorem reconstruction of m^d mod n, using
   m^dp mod p and m^dq mod q with dp = d mod p-1, dq = d mod q-1.
   */
#ifdef K_AND_R
static void
chineseRemTheorem(m, key, em)
  BigInt m, em;
  RSAPrivateKey *key;
#else
  static void chineseRemTheorem(BigInt m,
				RSAPrivateKey *key,
				BigInt em)
#endif
{
	BigInt u1, u2;
	BigInt p, q, dp, dq, c12;
	
	p = key-&gt;crt-&gt;p;
	q = key-&gt;crt-&gt;q;
	dp = key-&gt;crt-&gt;dp;
	dq = key-&gt;crt-&gt;dq;
	c12 = key-&gt;crt-&gt;c12;
	
	u1 = bigInit(0);
	u2 = bigInit(0);

	bigPow(m, dp, p, u1);
	bigPow(m, dq, q, u2);
	
	crtCombine(u1, u2, p, q, c12, em);
	
	freeBignum(u1);
	freeBignum(u2);
	
}

#ifdef K_AND_R
_TYPE( void )
freeRSAPublicKey(pk)
  RSAPublicKey *pk;
#else
_TYPE( void ) freeRSAPublicKey(RSAPublicKey *pk)
#endif
{
	freeBignum(pk-&gt;publicExponent);
	freeBignum(pk-&gt;modulus);
#ifdef DLLEXPORT
	GlobalUnlock(pk-&gt;pubkey_handle);
	GlobalFree(pk-&gt;pubkey_handle);
#else
	free((char *)pk);
#endif
}

#ifdef K_AND_R
_TYPE( void )
freeRSAPrivateKey(pk)
  RSAPrivateKey *pk;
#else
_TYPE( void ) freeRSAPrivateKey(RSAPrivateKey *pk)
#endif
{
	freeBignum(pk-&gt;publicExponent);
	freeBignum(pk-&gt;privateExponent);
	freeBignum(pk-&gt;modulus);
	freeBignum(pk-&gt;crt-&gt;p);
	freeBignum(pk-&gt;crt-&gt;q);
	freeBignum(pk-&gt;crt-&gt;dp);
	freeBignum(pk-&gt;crt-&gt;dq);
	freeBignum(pk-&gt;crt-&gt;c12);
#ifdef DLLEXPORT
	GlobalUnlock(pk-&gt;crt-&gt;crt_handle);
	GlobalFree(pk-&gt;crt-&gt;crt_handle);
	GlobalUnlock(pk-&gt;privkey_handle);
	GlobalFree(pk-&gt;privkey_handle);
#else
	free((char *)pk-&gt;crt);
	free((char *)pk);
#endif	
}

#ifdef K_AND_R
_TYPE( void )
freeRSAKeys(ks)
  RSAKeySet *ks;
#else
_TYPE( void ) freeRSAKeys(RSAKeySet *ks)
#endif
{
	
	freeRSAPublicKey(ks-&gt;publicKey);
	freeRSAPrivateKey(ks-&gt;privateKey);
#ifdef DLLEXPORT
	GlobalUnlock(ks-&gt;keyset_handle);
	GlobalFree(ks-&gt;keyset_handle);
#else
	free((char *)ks);
#endif
}

#ifdef K_AND_R
_TYPE( BigInt )
RSAEncrypt(message, key)
  BigInt message;
  RSAPublicKey *key;
#else
_TYPE( BigInt ) RSAEncrypt(BigInt message,
			   RSAPublicKey *key)
#endif
{
	BigInt result;
	
	result = bigInit(3);
	if (bigCompare(key-&gt;publicExponent, result) == 0) {
		reset_big(result, 0);
		bigCube(message, key-&gt;modulus, result);
	}
	else {
		reset_big(result, 0);
		bigPow(message, key-&gt;publicExponent, key-&gt;modulus, result);
	}
	return result;
}

#ifdef K_AND_R
_TYPE( BigInt )
RSADecrypt(message, key)
  BigInt message;
  RSAPrivateKey *key;
#else
_TYPE( BigInt ) RSADecrypt(BigInt message,
			   RSAPrivateKey *key)
#endif
{
	BigInt result;
	
	result = bigInit(0);
	
	chineseRemTheorem(message, key, result);
	return result;
	
}


#ifdef K_AND_R
_TYPE( RSASignature * )
RSASign(message, key)
  BigInt message;
  RSAPrivateKey *key;
#else
_TYPE( RSASignature * ) RSASign(BigInt message,
				RSAPrivateKey *key)
#endif
{
	return (RSASignature *)RSADecrypt(message, key);
}


#ifdef K_AND_R
_TYPE( Boolean )
RSAVerify(message, sig, key)
  BigInt message;
  RSASignature *sig;
  RSAPublicKey *key;
#else
_TYPE( Boolean ) RSAVerify(BigInt message,
			   RSASignature *sig,
			   RSAPublicKey *key)
#endif
{
	Boolean retval;
	BigInt cmp;
	
	cmp = (BigInt)RSAEncrypt((BigInt)sig, key);
	
	if (bigCompare(message, cmp) == 0)
		retval = TRUE;
	else
		retval = FALSE;
	
	freeBignum(cmp);
	
	return retval;
}

#ifdef K_AND_R
_TYPE( void )
freeRSASig(sig)
  RSASignature *sig;
#else
_TYPE( void ) freeRSASig(RSASignature *sig)
#endif
{
	freeBignum((BigInt)sig);
}

#ifdef K_AND_R
_TYPE( void )
RSAPrivateKeyDesEncrypt(pk, deskey)
  RSAPrivateKey *pk;
  unsigned char *deskey;
#else
_TYPE( void )
RSAPrivateKeyDesEncrypt(RSAPrivateKey *pk, unsigned char *deskey)
#endif
{
	bignumDesEncrypt(pk-&gt;publicExponent, deskey);
	bignumDesEncrypt(pk-&gt;privateExponent, deskey);
	bignumDesEncrypt(pk-&gt;modulus, deskey);
	bignumDesEncrypt(pk-&gt;crt-&gt;p, deskey);
	bignumDesEncrypt(pk-&gt;crt-&gt;q, deskey);
	bignumDesEncrypt(pk-&gt;crt-&gt;dp, deskey);
	bignumDesEncrypt(pk-&gt;crt-&gt;dq, deskey);
	bignumDesEncrypt(pk-&gt;crt-&gt;c12, deskey);
}

#ifdef K_AND_R
_TYPE( void )
RSAPrivateKeyDesDecrypt(pk, deskey)
  RSAPrivateKey *pk;
  unsigned char *deskey;
#else
_TYPE( void )
RSAPrivateKeyDesDecrypt(RSAPrivateKey *pk, unsigned char *deskey)
#endif
{
	bignumDesDecrypt(pk-&gt;publicExponent, deskey);
	bignumDesDecrypt(pk-&gt;privateExponent, deskey);
	bignumDesDecrypt(pk-&gt;modulus, deskey);
	bignumDesDecrypt(pk-&gt;crt-&gt;p, deskey);
	bignumDesDecrypt(pk-&gt;crt-&gt;q, deskey);
	bignumDesDecrypt(pk-&gt;crt-&gt;dp, deskey);
	bignumDesDecrypt(pk-&gt;crt-&gt;dq, deskey);
	bignumDesDecrypt(pk-&gt;crt-&gt;c12, deskey);
}

#ifdef K_AND_R
_TYPE( BigInt )
quantized_RSADecrypt(m, key)
  BigInt m;
  RSAPrivateKey *key;
#else
_TYPE( BigInt )
quantized_RSADecrypt(BigInt m, RSAPrivateKey *key)
#endif
{
	BigInt result;

	start_quantize(STD_QUANTUM);
	result = RSADecrypt(m, key);
	end_quantize();

	return result;
}


#ifdef K_AND_R
_TYPE( RSASignature *)
quantized_RSASign(m, key)
  BigInt m;
  RSAPrivateKey *key;
#else
_TYPE( RSASignature *)
quantized_RSASign(BigInt m, RSAPrivateKey *key)
#endif
{
	return (RSASignature *)quantized_RSADecrypt(m, key);
}






</code></pre></div></div><h2 id="thread">Thread</h2><ul><li><p>Return to <a href="/archive/1995/12">December 1995</a><li><p>Return to “<a href="/author/cpunk_at_remail_ecafe_org_ecafe_anonymous_remailer_">cpunk<span>@</span>remail.ecafe.org (ECafe Anonymous Remailer)</a>”<li><p>1995-12-28 (Thu, 28 Dec 95 09:21:40 PST) - Cryptolib 1.1 rsa.c - <em>cpunk@remail.ecafe.org (ECafe Anonymous Remailer)</em></ul><footer> - <a href="https://github.com/cryptoanarchywiki/mailing-list-archive">https://github.com/cryptoanarchywiki/mailing-list-archive</a></footer></div></div><script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script> <script src="//code.jquery.com/jquery-migrate-1.2.1.min.js"></script> <script src="/static/js/bootstrap.min.js"></script> <script src="/static/js/super-search.js"></script> <script src="/static/js/thickbox-compressed.js"></script> <script src="/static/js/projects.js"></script>
